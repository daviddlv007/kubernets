# üéì Proyecto Multi-Cloud Kubernetes - Notas del Estudiante

## üìö Conceptos Clave Implementados

### 1. Kubernetes Multi-Cluster
- **Definici√≥n**: M√∫ltiples clusters K8s independientes que trabajan juntos
- **Caso de uso**: Diferentes servicios en diferentes clouds
- **Implementaci√≥n aqu√≠**: 2 clusters K3s (k3d localmente, K3s en VMs para cloud)

### 2. Microservicios
- **Service A (Python/Flask)**: Orquestador, llama a Service B
- **Service B (Node.js/Express)**: Proveedor de datos
- **Comunicaci√≥n**: HTTP REST entre clusters

### 3. Service Discovery
- **Local**: LoadBalancer IPs din√°micas asignadas por K3s
- **Cloud**: IPs p√∫blicas de VMs o LoadBalancers externos
- **DNS**: CoreDNS dentro de cada cluster, HTTP directo entre clusters

### 4. GitOps (Opcional con ArgoCD)
- **Principio**: Git como √∫nica fuente de verdad
- **Flujo**: Git commit ‚Üí ArgoCD sync ‚Üí Cluster actualizado
- **Beneficio**: Auditor√≠a, rollback, automatizaci√≥n

### 5. Infraestructura como C√≥digo
- **Manifiestos YAML**: Definen estado deseado
- **Declarativo**: Kubernetes converge al estado definido
- **Reproducible**: Mismos archivos ‚Üí mismo resultado

---

## üî¨ Experimentos Sugeridos

### Experimento 1: Escalar Servicios
```bash
# Escalar Service A a 3 r√©plicas
kubectl --context=k3d-cluster1 scale deployment service-a --replicas=3

# Observar load balancing
for i in {1..10}; do curl http://<service-a-ip>/call; done
```

### Experimento 2: Simular Fallo
```bash
# Matar un pod
kubectl --context=k3d-cluster2 delete pod -l app=service-b

# Ver auto-recuperaci√≥n
kubectl --context=k3d-cluster2 get pods -w
```

### Experimento 3: Rolling Update
```bash
# Modificar c√≥digo de Service B
# Cambiar mensaje en server.js
# Reconstruir y desplegar
make build-images
make load-images
kubectl --context=k3d-cluster2 rollout restart deployment/service-b

# Ver actualizaci√≥n gradual
kubectl --context=k3d-cluster2 rollout status deployment/service-b
```

### Experimento 4: Health Checks
```bash
# Ver probes en acci√≥n
kubectl --context=k3d-cluster1 describe pod -l app=service-a | grep -A5 Liveness
kubectl --context=k3d-cluster1 describe pod -l app=service-a | grep -A5 Readiness

# Simular servicio unhealthy (comentar endpoint /health)
# Observar que K8s reinicia el pod
```

### Experimento 5: Resource Limits
```bash
# Ver uso actual
kubectl --context=k3d-cluster1 top pods

# Modificar limits en deployment.yaml
# Observar comportamiento con recursos limitados
```

---

## üìä Comparaci√≥n: Local vs Cloud

| Aspecto | Local (k3d) | Cloud (VMs) |
|---------|-------------|-------------|
| **Costo** | $0 | $10-15/mes |
| **Setup** | 5 minutos | 20 minutos |
| **Networking** | IPs privadas Docker | IPs p√∫blicas |
| **Persistencia** | No (al reiniciar) | S√≠ |
| **Realismo** | Medio | Alto |
| **Velocidad** | R√°pida | Depende de internet |
| **Debugging** | F√°cil (localhost) | SSH remoto |

---

## üéØ Objetivos de Aprendizaje Cubiertos

- ‚úÖ Entender arquitectura de microservicios
- ‚úÖ Kubernetes b√°sico (Pods, Services, Deployments)
- ‚úÖ Comunicaci√≥n inter-cluster
- ‚úÖ Containerizaci√≥n (Docker)
- ‚úÖ LoadBalancing
- ‚úÖ Health checks y self-healing
- ‚úÖ Resource management
- ‚úÖ GitOps (con ArgoCD)
- ‚úÖ Multi-cloud patterns
- ‚úÖ Infraestructura como c√≥digo

---

## üöÄ Posibles Extensiones

### Nivel 1: B√°sico
- [ ] Agregar un tercer servicio (Service C)
- [ ] Implementar un frontend web simple
- [ ] Agregar persistencia con Volumes
- [ ] Implementar variables de entorno con ConfigMaps

### Nivel 2: Intermedio
- [ ] Service mesh con Cilium o Istio
- [ ] Monitoring con Prometheus + Grafana
- [ ] Logging centralizado con Loki
- [ ] CI/CD con GitHub Actions
- [ ] Secrets management con Sealed Secrets

### Nivel 3: Avanzado
- [ ] mTLS entre servicios
- [ ] API Gateway (Kong/Ambassador)
- [ ] Distributed tracing (Jaeger)
- [ ] Chaos engineering (Chaos Mesh)
- [ ] Multi-region setup real

---

## üìñ Recursos para Aprender M√°s

### Kubernetes
- [Kubernetes Official Docs](https://kubernetes.io/docs/)
- [Kubernetes the Hard Way](https://github.com/kelseyhightower/kubernetes-the-hard-way)
- [CNCF Landscape](https://landscape.cncf.io/)

### K3s
- [K3s Documentation](https://docs.k3s.io/)
- [K3d Docs](https://k3d.io/)
- [Rancher Academy](https://www.rancher.academy/)

### GitOps
- [ArgoCD Docs](https://argo-cd.readthedocs.io/)
- [FluxCD Docs](https://fluxcd.io/docs/)
- [GitOps Working Group](https://opengitops.dev/)

### Microservicios
- [Microservices.io](https://microservices.io/)
- [12 Factor App](https://12factor.net/)
- [API Design Best Practices](https://learn.microsoft.com/en-us/azure/architecture/best-practices/api-design)

---

## ü§î Preguntas para Reflexionar

1. **¬øPor qu√© multi-cluster en lugar de un cluster grande?**
   - Aislamiento de fallos
   - Compliance/regulaciones
   - Latencia geogr√°fica
   - Vendor lock-in mitigation

2. **¬øCu√°ndo usar LoadBalancer vs NodePort vs ClusterIP?**
   - LoadBalancer: Acceso externo (cloud)
   - NodePort: Testing, acceso directo a nodes
   - ClusterIP: Solo interno al cluster

3. **¬øDiferencias entre K8s completo y K3s?**
   - K3s: Ligero, single binary, edge computing
   - K8s: Full features, enterprise, m√°s recursos

4. **¬øCu√°ndo usar ArgoCD vs kubectl directo?**
   - ArgoCD: M√∫ltiples clusters, equipos, automatizaci√≥n
   - kubectl: Desarrollo local, debugging, pruebas r√°pidas

---

## üìù Notas de Implementaci√≥n

### Decisiones de Dise√±o

1. **K3d en lugar de Kind**
   - K3s es lo que se usa en VMs reales
   - Misma experiencia local ‚Üí cloud
   - Traefik incluido como LoadBalancer

2. **Manifiestos YAML en lugar de Helm**
   - M√°s educativo ver YAML completo
   - Menos abstracciones
   - F√°cil de entender qu√© hace cada campo

3. **LoadBalancer en lugar de Ingress**
   - M√°s simple para empezar
   - Funciona out-of-the-box con K3s
   - M√°s cercano a cloud (ELB, Cloud Load Balancer)

4. **Python + Node.js**
   - Demuestra polyglot architecture
   - Lenguajes populares y f√°ciles
   - Ecosistemas diferentes

---

## üèÜ M√©tricas de √âxito

Tu proyecto est√° funcionando correctamente si:

- ‚úÖ Puedes crear ambos clusters en <2 minutos
- ‚úÖ Services se despliegan sin errores
- ‚úÖ Health checks pasan (ready/alive)
- ‚úÖ Service A llama exitosamente a Service B
- ‚úÖ Puedes escalar servicios sin downtime
- ‚úÖ Puedes hacer rolling updates
- ‚úÖ Los pods se auto-recuperan de fallos
- ‚úÖ Puedes migrar a cloud con m√≠nimos cambios

---

## üí° Tips de Debugging

```bash
# 1. Ver todo
kubectl get all --all-namespaces

# 2. Describir recursos
kubectl describe pod <pod-name>
kubectl describe svc <service-name>

# 3. Logs en tiempo real
kubectl logs -f <pod-name>

# 4. Ejecutar dentro del pod
kubectl exec -it <pod-name> -- /bin/sh

# 5. Ver eventos
kubectl get events --sort-by='.lastTimestamp'

# 6. Port forwarding para debug
kubectl port-forward pod/<pod-name> 8080:8080

# 7. Ver configuraci√≥n actual
kubectl get deployment <name> -o yaml

# 8. Ver diferencias
kubectl diff -f deployment.yaml
```

---

## üéâ Conclusi√≥n

Este proyecto te da una base s√≥lida en:
- Kubernetes multi-cluster
- Microservicios distribuidos
- Cloud-native patterns
- DevOps/GitOps workflows

**Pr√≥ximo paso**: Despliega en cloud real y experimenta con las extensiones sugeridas.

¬°Buena suerte! üöÄ
